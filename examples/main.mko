;(module console org.mko.core/console)
;(fun int main (int a int b)
     ;(console.log "Hello World!"))

; Native Primitive types
; int-type
; int16-type
; int32-type
; int64-type
; bool-type
; byte-type
; str-type
; num-type
; list-type
; gen-type

; A define is constructing a object based on a declaration
; A declaration can be of following types
;  structure
;  lambda
;  block

; Don't be alarmed about the verbosity of the code bellow. This is the lowest level and should not be used in every day programming. In the future Macros will be the interface to the programmer, and the Macros will hide all of this making declarations and definitions intuitiv and simple.

; Lets declare a struct
; META       KEYWORD   TYPE-NAME       TYPES IN STRUCT
((meta tags) structure my-struct-type (int-type str-type num-type))

; Lets define a variable of that type
; META       KEYWORD TYPE-NAME      VAR-NAME  VALUES TO INSERT
((meta tags) define  my-struct-type my-var   (1 "hello", 10.2))

; Lets declare a function type
; META       KEYWORD TYPE-NAME    RETURN   ARG-A    ARG-B
((meta tags) lambda  my-fun-type (num-type num-type num-type))

; META       KEYWORD TYPE-NAME   FUNCTION NAME   ARG-A ARG-B
((meta tags) define  my-fun-type my-fun         (arg-a arg-b)
;                                                KEYWORD LABEL
                                                (block   entry (; META       EXPRESSION
                                                                ;            FUN ARG   ARG
                                                                ((meta tags) add arg-a arg-b))))

; Generic types with gen-type
; A generic type is unknown until we compile the code. Let's create an example based upon the previous example that adds two numbers. Add works on any type of integers and number. The compiler only needs to know what the add function can handle to decide what my-fun would allow.

; Lets declare a function type
; META       KEYWORD TYPE-NAME    RETURN   ARG-A    ARG-B
((meta tags) lambda  my-fun-type (gen-type gen-type gen-type))

; Define it
; META       KEYWORD TYPE-NAME   FUNCTION NAME   ARG-A ARG-B
((meta tags) define  my-fun-type my-fun         (arg-a arg-b)
;                                                KEYWORD LABEL
                                                (block   entry (; META       EXPRESSION
                                                                ;            FUN ARG   ARG
                                                                ((meta tags) add arg-a arg-b))))

; Now you can call my-fun with any arguments that add can handle. How is the add function declared then?

; Lets declare a function type
; META       KEYWORD TYPE-NAME    RETURN   ARG-A    ARG-B
((meta tags) lambda  my-fun-type (byte-type byte-type byte-type))
((meta tags) lambda  my-fun-type (int16-type int16-type int16-type))
((meta tags) lambda  my-fun-type (int32-type int32-type int32-type))
((meta tags) lambda  my-fun-type (int64-type int64-type int64-type))
((meta tags) lambda  my-fun-type (num-type num-type num-type))

; You can imagine declarations where two 16-bit int becomes a 32 bit and so on
((meta tags) lambda  my-fun-type (int32-type int16-type int16-type))
